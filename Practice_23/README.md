# Практика #23


## Практика #1
Приведите пример перегруженных методов.
```java
class Calculator {

    // Метод для сложения двух целых чисел
    public int add(int a, int b) {
        return a + b;
    }

    // Метод для сложения трех целых чисел
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Метод для сложения двух чисел с плавающей точкой
    public double add(double a, double b) {
        return a + b;
    }

    // Метод для сложения двух строк (конкатенация)
    public String add(String a, String b) {
        return a + b;
    }

}

public class TestCalculator {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        // Вызов метода для сложения двух целых чисел
        System.out.println("Сумма 2 и 3: " + calc.add(2, 3));

        // Вызов метода для сложения трех целых чисел
        System.out.println("Сумма 1, 2 и 3: " + calc.add(1, 2, 3));

        // Вызов метода для сложения двух чисел с плавающей точкой
        System.out.println("Сумма 2.5 и 3.5: " + calc.add(2.5, 3.5));

        // Вызов метода для конкатенации строк
        System.out.println("Конкатенация 'Hello' и ' World': " + calc.add("Hello", " World"));
    }
}

```


## Практика #2
Приведите пример переопределенного метода. Что будет, если у переопределенного и переопределяемого (из суперкласса) методов не будет совпадать тип возвращаемого значения?
```java
class Animal {
    // Метод в суперклассе
    public Animal makeSound() {
        System.out.println("Животное издает звук");
        return this;
    }
}

class Dog extends Animal {
    // Переопределенный метод в подклассе
    @Override
    public Dog makeSound() {
        System.out.println("Собака лает");
        return this;  // Возвращаем объект типа Dog, что является подтипом Animal
    }
}

public class TestOverride {
    public static void main(String[] args) {
        Animal animal = new Animal();
        animal.makeSound();  // Выведет: Животное издает звук
        
        Dog dog = new Dog();
        dog.makeSound();  // Выведет: Собака лает
    }
}

```
Корректное переопределение:

В классе Dog мы переопределяем метод makeSound() из класса Animal, и тип возвращаемого значения в обоих классах — Animal. Поскольку класс Dog является подклассом Animal, возвращаемый тип Dog можно использовать вместо Animal, это называется ковариантным возвращаемым типом. Таким образом, это переопределение корректно.
Некорректное переопределение:

В классе Dog мы пытаемся вернуть строку (String), а не объект типа Animal. Это нарушение правила совместимости типов возвращаемого значения, и поэтому компилятор выдаст ошибку.

## Практика #3
Приведите пример и объясните, когда использование аннотации @Override помогает обнаружить ошибку.
```java
class Animal {
    public void makeSound() {
        System.out.println("Животное издает звук");
    }
}

class Dog extends Animal {
    @Override
    public void makeSoud() {  // Ошибка в имени метода
        System.out.println("Собака лает");
    }
}

public class TestOverride {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.makeSound();  // Это не скомпилируется из-за ошибки в методе makeSoud()
    }
}

```
Когда @Override помогает предотвратить ошибки:
Ошибки в имени метода: Если имя метода в подклассе не совпадает с именем метода в суперклассе, компилятор выдаст ошибку. Аннотация @Override помогает избежать ситуации, когда метод в подклассе не является переопределением (например, из-за опечатки в названии метода).

Ошибки в параметрах метода: Если параметры метода в подклассе не соответствуют параметрам метода в суперклассе (например, разное количество или тип параметров), компилятор также обнаружит это, если используется аннотация @Override.

Ошибки при изменении сигнатуры метода в суперклассе: Если мы изменяем сигнатуру метода в суперклассе (например, изменяем его тип возвращаемого значения или количество параметров), аннотация @Override позволяет легко обнаружить такие ошибки в подклассе, так как компилятор сообщит о несовпадении сигнатур.

